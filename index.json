[{"content":"实践一、\n我的 github page 仓库，有一个 main 分支\n我本地新建了一个仓库，想把内容完全覆盖掉仓库\n初始化本地仓库 git init ，初始化本地 git 仓库\n1 git init 添加远程仓库链接 将新文件夹与GitHub上的远程仓库关联。替换\u0026lt;your-repo-url\u0026gt;为您实际的远程仓库URL。\n1 git remote add origin \u0026lt;your-repo-url\u0026gt; 将文件夹内容添加到 Git，并提交 1 2 git add . git commit -m \u0026#34;Replace repository content\u0026#34; 强制推送到 Github 使用--force或-f选项强制推送本地内容到远程仓库。这会覆盖远程仓库的所有内容，请确保您已备份重要数据。\n1 git push origin master --force 请注意，使用--force会覆盖远程仓库的历史记录，因此需要谨慎使用。\n解释下强制推送\n在 Git 中，git push origin master --force 这条命令用于将本地分支的更改强制推送到远程仓库。以下是命令中各部分的含义：\npush: 这是 Git 的一个命令，用于将本地仓库的更改推送（上传）到远程仓库。 origin: 这是远程仓库的默认名称，通常在克隆或远程关联时被使用。它只是一个指向实际远程仓库URL的别名。如果你将某个远程仓库关联到本地仓库时使用了不同名称，那么你需要用相应的名称替换掉 origin。 master: 在早期版本的 Git 中，master 是默认的主分支名称。近年来，Git 开始使用 main 作为新仓库的默认主分支名称。如果你的仓库使用的是 main，那么这部分应改为 main。具体分支名称应根据仓库实际情况调整。 --force: 该选项强制执行推送，即使这会使远程仓库的历史记录发生不一致的变化。使用强制推送会覆盖远程仓库中当前的分支历史记录，因此应该谨慎使用，确保不影响他人或数据丢失。 总之，git push origin master --force 将会强制把本地的 master 分支推送到远程仓库的 master 分支上，可能会覆盖掉远程分支的现有提交记录。在开始使用之前确保你理解其潜在的风险和影响。\n修改分支远程仓库名称\n使用以下命令将远程仓库的名称从 main 更改为 origin：\n1 git remote rename main origin 验证更改是否成功，运行以下命令查看远程仓库列表及其 URL：\n1 git remote -v 触发 page 更新\n","permalink":"https://wangkai26.github.io/posts/git/git%E5%AE%9E%E8%B7%B5/","summary":"实践一、 我的 github page 仓库，有一个 main 分支 我本地新建了一个仓库，想把内容完全覆盖掉仓库 初始化本地仓库 git init ，初始化本地 git 仓库 1 git init 添加远程仓库链接 将新","title":"Git实践"},{"content":"","permalink":"https://wangkai26.github.io/posts/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","summary":"","title":"常用命令"},{"content":"听起来是个不错的选择！“协议与数据通信”这个文件夹名非常直观，可以很好地容纳未来与数据格式、协议、通信机制相关的文章。如果你考虑到后续可能会扩展到其它协议（例如XML、JSON、gRPC等），这个目录将显得更加实用且条理清晰。\n在撰写新文章时，你可以考虑以下几点，使其更具吸引力和实用性：\n背景介绍： 简述为什么选择Protobuf，以及它与其它协议的优劣比较。 使用场景： 讨论适合使用Protobuf的典型场景，如微服务之间的通信、大量数据传输等。 基础使用： 如何定义消息格式、编译Protobuf文件以及如何在各种语言中使用生成的代码。 实例演示： 提供一些简单的代码示例来展示Protobuf在实际开发中的应用。 高级特性： Protobuf的高级特性，例如自定义选项、嵌套消息、enum���型等。 最佳实践： 分享一些在使用Protobuf过程中的经验和最佳实践。 希望这些建议对你的写作有所帮助！如果在写作过程中有其他问题，随时欢迎交流。祝你的博客写作顺利！\n","permalink":"https://wangkai26.github.io/posts/%E5%8D%8F%E8%AE%AE%E4%B8%8E%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F/protobuf%E7%90%86%E8%AE%BA/","summary":"听起来是个不错的选择！“协议与数据通信”这个文件夹名非常直观，可以很好地容纳未来与数据格式、协议、通信机制相关的文章。如果你考虑到后续可能会","title":"Protobuf理论"},{"content":"","permalink":"https://wangkai26.github.io/posts/front_end/element-ui%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%8C/","summary":"","title":"Element Ui常用手册"},{"content":"什么是 free loop？\n在Python中，\u0026ldquo;loop free\u0026rdquo; 通常不是一个正式的术语。然而，它可能会指代一些编程习惯或技术，它们旨在避免显式使用循环（如for循环或while循环）的情况下实现某些功能，以提高效率或简化代码。\n以下是一些常见的“loop free”技术或方法，它们可能与for循环相比有更好的性能，或代码更简洁：\n列表推导（List Comprehensions）： 列表推导是一种在Python中创建新列表的简洁方式，它可以在单行代码中完成对列表的构建和处理，通常比使用传统for循环更快、更清晰。 示例：squared_numbers = [x**2 for x in range(10)] 生成器表达式（Generator Expressions）： 类似于列表推导，生成器表达式则是在使用时才生成元素，常用于处理数据流或大型数据集，因为它们节省内存。 示例：squared_numbers = (x**2 for x in range(10)) 内置函数（Built-in Functions）： Python有许多内置函数如map、filter、sum等，可以在不显式编写循环的情况下对数据进行操作。 示例：squared_numbers = list(map(lambda x: x**2, range(10))) 函数式编程（Functional Programming）： 使用高阶函数如reduce（来自functools模块）和递归，也能实现循环的效果。 示例：利用reduce对列表求和：from functools import reduce; total_sum = reduce(lambda x, y: x + y, range(10)) 矢量化操作： 在处理数值数据时，使用NumPy等库的矢量化操作可以避免使用Python循环，因为这些操作是在底层的C语言实现中批量完成的，通常速度更快。 示例：import numpy as np; a = np.array([1, 2, 3]); squared_a = a**2 选择是否使用“loop free”方法要根据具体情况、代码可读性、团队代码规范等多方面综合考虑。虽然这些方法在某些情况下能提高效率和代码整洁度，但也并非总是最佳选择。\n","permalink":"https://wangkai26.github.io/posts/python%E7%89%B9%E6%80%A7%E5%92%8C%E5%90%84%E7%A7%8D%E5%8C%85/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/","summary":"什么是 free loop？ 在Python中，\u0026ldquo;loop free\u0026rdquo; 通常不是一个正式的术语。然而，它可能会指代一些编程习惯或技术，它们旨在避免显式使","title":"函数式编程"},{"content":"mysql基础\n","permalink":"https://wangkai26.github.io/posts/database/mysql%E5%9F%BA%E7%A1%80/","summary":"mysql基础","title":"MySQL基础"},{"content":"解包就是把可迭代对象（如列表lists, 元组tuples和字典dictinaries）的内容取出来的操作。\n* 和 ** 通常用于函数定义和调用时处理可变数量的参数。\nPython 中有两个特殊的操作符：* 和 **，它们有两种用途：参数解包和序列解包。\n序列解包：用于将序列（如列表或元组）中的元素解包为独立的参数 参数解包：在函数定义中，* 用于收集额外的位置参数到一个元组中，而 ** 用于收集额外的关键字参数到一个字典中。 它们通常用于函数定义和调用时处理可变数量的参数。\n* 操作符 在函数定义中使用：当在函数定义中使用时，* 用于将可变数量的非关键字参数打包成一个元组。例如：\n1 2 3 4 5 def my_function(*args): for arg in args: print(arg) my_function(1, 2, 3) 在这个例子中，my_function 可以接收任意数量的参数，这些参数会被收集到一个名为 args 的元组中。\n在函数调用中使用：当在函数调用中使用时，* 用于将一个序列解包成单个元素。例如：\n1 2 3 4 5 def my_function(a, b, c): print(a, b, c) args = (1, 2, 3) my_function(*args) 这里，*args 会解包为 1, 2, 3，并传递给 my_function。\n** 操作符 在函数定义中使用：当在函数定义中使用时，** 用于将可变数量的关键字参数打包成一个字典。例如：\n1 2 3 4 5 def my_function(**kwargs): for key, value in kwargs.items(): print(f\u0026#34;{key}: {value}\u0026#34;) my_function(name=\u0026#34;Alice\u0026#34;, age=30) 在这个例子中，my_function 可以接收任意数量的关键字参数，这些参数会被收集到一个名为 kwargs 的字典中。\n在函数调用中使用：当在函数调用中使用时，** 用于将一个字典解包为关键字参数。例如：\n1 2 3 4 5 def my_function(name, age): print(f\u0026#34;{name} is {age} years old\u0026#34;) kwargs = {\u0026#34;name\u0026#34;: \u0026#34;Bob\u0026#34;, \u0026#34;age\u0026#34;: 25} my_function(**kwargs) 这里，**kwargs 会解包字典的内容，并传递给 my_function 作为关键字参数。\n总结来说，* 和 ** 操作符可以帮助你在函数中灵活地处理不定数量的参数，使得函数更加通用和易用。\n解包列表或元组 将列表或元组中的元素解包为独立参数。\n1 2 3 4 5 6 def add(a, b, c): return a + b + c numbers = [1, 2, 3] result = add(*numbers) # 等同于 add(1, 2, 3) print(result) # 输出 6 合并列表或元组 将多个列表或元组合并后作为参数传递。\n1 2 3 4 5 6 7 def add_all(*args): return sum(args) numbers1 = [1, 2, 3] numbers2 = [4, 5, 6] result = add_all(*numbers1, *numbers2) # 等同于 add_all(1, 2, 3, 4, 5, 6) print(result) # 输出 21 与内置函数结合 使用 ** 可以与内置函数如 dict 结合，创建字典。\n1 2 3 user_data = [\u0026#39;name\u0026#39;, \u0026#39;Charlie\u0026#39;, \u0026#39;age\u0026#39;, 40] user_dict = dict(zip(*[iter(user_data)]*2)) print(user_dict) 以上例子可能有些难以理解，可以先了解 zip():\nzip()函数 zip 函数用于将可迭代的对象(如列表、元组、字符串)作为参数，用于将多个可迭代对象（如列表、元组、字符串等）“压缩” 成一个元组的迭代器。每个元组包含输入的可迭代对象在相同位置的元素。使用zip()可以轻松地将多个序列中对应的元素组合在一起。\n1 2 3 4 list1 = [1, 2, 3] list2 = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;] zipped = zip(list1, list2) print(list(zipped)) # [(1, \u0026#39;a\u0026#39;), (2, \u0026#39;b\u0026#39;), (3, \u0026#39;c\u0026#39;)] 接下来我们逐步解析 dict(zip(*[iter(user_data)]*2))：\niter(user_data) 将列表 user_data 转换为迭代器。 [iter(user_data)]*2 将迭代器重复两次，得到 [iter(user_data), iter(user_data)]。 *[iter(user_data)]*2: 将列表解包为两个都是 iter(user_data) 的独立参数。 zip(*[iter(user_data)]*2): 将参数列表打包为元组的迭代器，由于传入的两个参数是同一个迭代器，所以每解析完一个键，迭代器就移动到下一个元素将下一个元素作为值，由此将 user_data 列表中的元素两两配对。 dict(zip(*[iter(user_data)]*2)): dict() 函数接受一个键值对序列，并返回一个新的字典。 解包 解包字典 将字典中的键值对解包为关键字参数。\n1 2 3 4 5 def create_user(name, age, city): print(f\u0026#34;Name: {name}, Age: {age}, City: {city}\u0026#34;) user_info = {\u0026#39;name\u0026#39;: \u0026#39;Bob\u0026#39;, \u0026#39;age\u0026#39;: 25, \u0026#39;city\u0026#39;: \u0026#39;Boston\u0026#39;} create_user(**user_info) # 等同于 create_user(name=\u0026#39;Bob\u0026#39;, age=25, city=\u0026#39;Boston\u0026#39;) 动态函数调用 动态地将字典传递给不同的函数。\n1 2 3 4 5 6 7 8 def send_email(to, subject, body): print(f\u0026#34;Sending email to {to}: {subject}\\n{body}\u0026#34;) # 邮件信息 email_info = {\u0026#39;to\u0026#39;: \u0026#39;alice@example.com\u0026#39;, \u0026#39;subject\u0026#39;: \u0026#39;Meeting\u0026#39;, \u0026#39;body\u0026#39;: \u0026#39;Let\\\u0026#39;s meet up today.\u0026#39;} # 动态发送邮件 send_email(**email_info) ","permalink":"https://wangkai26.github.io/posts/python%E7%89%B9%E6%80%A7%E5%92%8C%E5%90%84%E7%A7%8D%E5%8C%85/%E8%A7%A3%E5%8C%85%E6%93%8D%E4%BD%9C%E7%AC%A6/","summary":"解包就是把可迭代对象（如列表lists, 元组tuples和字典dictinaries）的内容取出来的操作。 * 和 ** 通常用于函数定义和调用时处理","title":"解包操作符"},{"content":"拼魔方\n三阶魔方基础知识： 结构： 三阶魔方有六个面，每面有九个小方块，一共54个小方块。 每个面都可以用一种颜色表示，传统上有白、黄、红、橙、绿、蓝。 中心块（六个）：决定了每个面最终的颜色，因为它们的相对位置固定。 棱块（12个）：每个有两种颜色。 角块（8个）：每个有三种颜色。 旋转： 魔方的转动可以分为U（上层）、D（下层）、L（左层）、R（右层）、F（前层）、B（后层）和它们的逆时针转（以\u0026rsquo;表示，例如U\u0026rsquo;）。 2表示180度转动，比如U2。 三阶魔方还原步骤和公式： 1. 打十字（第一层十字）：\n目标是将一个面（通常是白色）放好一个“十”字。 可以使用基本的旋转来移动棱块到正确的位置。 2. 第一层角块：\n把第一层的角块转到对应位置，并正确调整方向。 常用公式：R U R' 3. 第二层棱块：\n将第二层的棱块放到正确位置。 若棱块在右侧：U R U\u0026rsquo; R\u0026rsquo; U\u0026rsquo; F\u0026rsquo; U F 若棱块在左侧：U\u0026rsquo; L\u0026rsquo; U L U F U\u0026rsquo; F' 4. 顶层十字：\n顶层做成一个十字。 F R U R\u0026rsquo; U\u0026rsquo; F' 5. 顶层边缘颜色统一：\nU R U\u0026rsquo; L\u0026rsquo; U R\u0026rsquo; U\u0026rsquo; L 6. 顶层角块位置：\n调整顶层角块的位置，使其在正确的位置但可能面向错误。 U R U\u0026rsquo; L\u0026rsquo; U R\u0026rsquo; U\u0026rsquo; L 7. 顶层角块方向调整：\n将角块朝向正确方向。 R\u0026rsquo; D\u0026rsquo; R D 这些只是基本的公式，初次学习可能需要多练习，多去理解每个步骤的意义。建议多找教程视频对照学习，这样更直观些。\n如果有其他问题或者需要进一步的帮助，请随时告诉我！\n还原公式-通俗版 按我的理解写的步骤：分三大步，第一层、第二层 和 第三层\n一、第一层\n先拼出白色十字，\n二、第二层\n也就是拼第二层的棱块\n先在第三层找到不含有黄色的棱块，比如 发现 蓝橙 棱块，将对着我们的颜色块和第二层的中心块对齐，比如橙色，然后另一个蓝色，一定在 左边 或者右边，\n右边：先左移顶层（远离蓝色）， 左上左下右，然后换位置，左手拿当前面，左手做 上右下左，\n左边：先右移顶层（远离上方对应色块），左手 上右下左，将当前面移动到右手边，右手 上左下右\n三、垫层\n1.口诀一:\u0026ldquo;上左下右上\u0026quot;将底部十字对齐之后,再找到任意两面相邻的侧面,每个面上 面部分两个颜色一样,应用这个口诀可以将四面,每一个面上面部分的两个颜色都变成一 样,主要是处理棱块颜色。 2.口诀二:\u0026ldquo;上左下右\u0026rdquo;,底面十字做好之后,将立方体转180度,底面朝下,通过这个 口诀,将底面的颜色全部做好。 3.口诀三:上面左移,右手做\u0026quot;上左下右\u0026rdquo;,立方体向左转90度度,左手做\u0026quot;上右下左\u0026quot;。 这是找顶层没有浅黄色的块儿,将其中一面色长条对齐,看另一面的颜色,如果这个颜色 和右面中心块的颜色一样的话,可以用这个口诀。 4.口诀四:上面右移,左手做\u0026quot;上右下左\u0026quot;,立方体向右转90度度,右手做\u0026quot;上左下右\u0026quot;。 这是找顶层没有浅黄色的块儿,将其中一面色长条对齐,看另一一面的颜色,如果这个颜色 和左面中心块的颜色一样的话,可以用这个口诀。 5.口诀五:前面顺时针旋转90度,应用口诀\u0026quot;上左下右\u0026quot;再将前面逆时针旋转90度。这 个口诀用于做出\u0026quot;顶层十字\u0026quot;。 6.口诀六:\u0026ldquo;下右上右下右右上\u0026quot;这个口诀主要做出顶层小鱼开状,再继续做出顶面全部 颜色。 7.口诀七:\u0026ldquo;上右上,下面顺时针转180度,下左上,下面顺日付针旋转180度,右侧面逆 时针旋转180\u0026quot;这个口诀主要用于做好侧面棱块。 8.口诀八:\u0026ldquo;下左下右下左上左上左,逆时针旋转180度\u0026rdquo;,这个口诀是将其中一个好的 侧面,对着自己,顶面是做好的状态,做好这个口诀,魔方就还还原了。\n","permalink":"https://wangkai26.github.io/posts/life/%E9%AD%94%E6%96%B9/","summary":"拼魔方 三阶魔方基础知识： 结构： 三阶魔方有六个面，每面有九个小方块，一共54个小方块。 每个面都可以用一种颜色表示，传统上有白、黄、红、橙、绿、","title":"魔方"},{"content":"设计模式主要分为三大类，每一类又包含多个具体的设计模式：\n创建型模式：这类模式主要关注对象创建过程。常见的有：\n单例模式（Singleton） 工厂方法模式（Factory Method） 抽象工厂模式（Abstract Factory） 建造者模式（Builder） 原型模式（Prototype） 结构型模式：这类模式主要关注类和对象的组合。常见的有：\n适配器模式（Adapter） 桥接模式（Bridge） 组合模式（Composite） 装饰器模式（Decorator） 外观模式（Facade） 享元模式（Flyweight） 代理模式（Proxy） 行为型模式：这类模式主要关注对象之间的职责分配与通信。常见的有：\n责任链模式（Chain of Responsibility） 命令模式（Command） 解释器模式（Interpreter） 迭代器模式（Iterator） 中介者模式（Mediator） 备忘录模式（Memento） 观察者模式（Observer） 状态模式（State） 策略模式（Strategy） 模板方法模式（Template Method） 访问者模式（Visitor） 关于Python的装饰器，它属于结构型模式中的装饰器模式（Decorator）。装饰器模式主要用于动态地给对象添加一些额外的功能，而不影响其他对象。Python的装饰器语法非常方便，用于增强函数的功能，非常符合装饰器模式的概念。\n","permalink":"https://wangkai26.github.io/posts/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","summary":"设计模式主要分为三大类，每一类又包含多个具体的设计模式： 创建型模式：这类模式主要关注对象创建过程。常见的有： 单例模式（Singleton） 工","title":"设计模式"},{"content":"11111111\ndef app_bitmap_read_bit(pstr, struct_c): \u0026ldquo;\u0026ldquo;\u0026ldquo;按bit读取数据\u0026rdquo;\u0026rdquo;\u0026rdquo; struct_dict = copy.copy(struct_c) # 浅拷贝，不修改内部数据 bit_values = list(struct_dict.values()) bit_keys = list(struct_dict.keys()) index = -bit_values[0] del bit_values[0] pstr = str(bin(hex_to_int(\u0026ldquo;1\u0026rdquo; + rever_bytes(pstr)))).split(\u0026ldquo;0b1\u0026rdquo;)[1] # \u0026ldquo;1\u0026rdquo; 无效数据 struct_dict[bit_keys[0]] = bin_to_int(pstr[index:]) for i in range(len(bit_values)): bit_result = bin_to_int(pstr[-(-index + bit_values[i]):index]) # 反向获取数据 struct_dict[bit_keys[i+1]] = bit_result index += -bit_values[i]\nclass struct_data(object): def __init__(self): names = self.__dict__ for key,value in struct_dict.items(): # 动态赋值变量 names[key] = value return struct_data() ","permalink":"https://wangkai26.github.io/posts/front_end/js%E5%9F%BA%E7%A1%80/","summary":"11111111 def app_bitmap_read_bit(pstr, struct_c): \u0026ldquo;\u0026ldquo;\u0026ldquo;按bit读取数据\u0026rdquo;\u0026rdquo;\u0026rdquo; struct_dict = copy.copy(struct_c) # 浅拷贝，不修改内部数据 bit_values","title":"Js基础"},{"content":"请帮我分析一段代码，代码如下：\n1 2 3 4 5 6 with open(filename, \u0026#39;rb\u0026#39;) as fp: ff=fp.read() # print(ff) hexstr = binascii.b2a_hex(ff).decode() print(hexstr) ff 是我读取到的内容，直接打印 ff 会得到 二进制数据，通过 binascii.b2a_hex(ff).decode() 会得到十六进制字符串，请帮我分析下，原文件的内容是什么格式的数据，二进制吗？binascii.b2a_hex(ff).decode() 就是把二进制数据转换成十六进制？怎么转换，请具体描述这个过程\n在这段代码中，with open(filename, 'rb') as fp 用于以二进制模式打开一个文件，这意味着你读取到的内容是以字节（byte）的形式存在的，因此 ff 是一个包含字节数据的二进制对象。\nbinascii.b2a_hex(ff) 是将这些字节数据转换为它们的十六进制表示形式。具体而言，这个函数会将每个字节（8位）转换为两个十六进制字符（每个字符占4位）。举个简单的例子，假设你的字节是 0xAB，它的十六进制表示就是 'ab'。每个字节被转化成两个字符后，所有字符连接在一起就得到了一个完整的十六进制字符串。\n在 binascii.b2a_hex(ff).decode() 中，.decode() 被用来将这个字节串转换成一个普通的Python字符串对象，它默认使用UTF-8进行解码。这样你就可以用print(hexstr)来查看这个可读的十六进制字符串。\n总结一下，这个过程是将文件中的二进制字节数据转换为一个可读的十六进制字符串表示，方便进行查看和进一步处理。\npython中还能用什么函数实现一样的功能呢？将二进制数据转换为十六进制字符串\n在Python中，将二进制数据转换为十六进制字符串，有多种方式可以实现，除了使用binascii.b2a_hex，这里有几个常用的方法：\n使用hex()方法（仅适用于bytes对象）：\n1 hexstr = ff.hex() 使用binascii.hexlify：\n1 2 import binascii hexstr = binascii.hexlify(ff).decode() 使用format与字符串格式化：\n1 hexstr = \u0026#39;\u0026#39;.join(format(byte, \u0026#39;02x\u0026#39;) for byte in ff) 使用codecs模块的encode函数：\n1 2 import codecs hexstr = codecs.encode(ff, \u0026#39;hex\u0026#39;).decode() 这些方法都可以实现二进制数据到十六进制字符串的转换功能。选择使用哪种方法可以根据个人的代码习惯或者项目的具体需求，只要能够正确得到预期的结果即可。\n问题：.decode() 被用来将这个字节串转换成一个普通的Python字符串对象 请再详细讲下上面这句话，我不太明白 我打印 没有 decode 和 decode 的数据，感觉打印结果就是差了一个 b\u0026rsquo;\u0026rsquo;，如下： b'484600‘ 484600\nAI\n在Python中，字符串有两种主要形式：字节串（bytes）和字符串对象（通常指文本字符串，str）。\n字节串（bytes）： 以 b'' 前缀表示。 适合处理二进制数据，如文件、网络数据等。 每个元素是一个字节，数值范围在0到255之间。 字符串对象（str）： 以 '' 表示。 用于处理文本数据，支持多种编码形式。 是Python中常用的字符串格式，适合大多数文本处理任务。 在你提到的代码中，binascii.hexlify(ff) 或 binascii.b2a_hex(ff) 返回的是一个字节串，因为这些函数返回的结果是原始的二进制数据的十六进制表示，它仍然是以字节格式存在的，因此会用b''表现出来。\n.decode() 方法的作用就是将这个字节串按照指定的编码（默认是 \u0026lsquo;utf-8\u0026rsquo;）解码成一个标准的Python字符串对象（str）。这样，b'484600' 就变成了 '484600'，去掉了 b''，使得字符串更符合日常的文本处理与查看。\n所以，decode() 的作用是把从二进制数据表示（字节串）转换为文本表示（普通字符串），这通常也是为了更方便的进行文本处理和输出。\n问题：在Python中，字符串有两种主要形式：字节串（bytes）和字符串对象（通常指文本字符串，str） 这句话我不理解，都说了字符串了，怎么还包含字节串的形式呢\nAI\n在Python中，虽然我们通常把\u0026quot;字符串\u0026quot;用来指代文本字符串，但是在处理不同类型数据时，需要区分字节串（bytes）和文本字符串（str）。这两者都可以用来表示字符串数据，但它们的用途和表现形式有所不同。\n文本字符串（str）： 用来处理文本数据。 是Python中默认的字符串类型。 支持多种字符编码（如UTF-8、UTF-16等），是一种Unicode字符串。 通常用于表示和处理人类可读的文本。 字节串（bytes）： 专门用来处理二进制数据。 以 b'' 前缀表示。例： b'hello' 其元素是字节数据（整数值范围从0到255）。 通常用于网络通信、文件读写或者加密操作等需要原始二进制数据的场合。 这两种形式的区别很重要，因为它们用于不同的场合：\n使用文本字符串（str）处理文本，如打印输出、显示用户界面文本、文本解析等。 使用字节串（bytes）处理二进制数据，如传输字节流、处理编码数据、网络通信等。 当需要在这两者之间转换时，可以使用 .encode() 将文本字符串转换为字节串，用 .decode() 将字节串转换为文本字符串。这两种类型的分离是因为在处理国际化、网络通信、文件格式等时，对二进制和文本进行明确的区分是很重要的。\n","permalink":"https://wangkai26.github.io/posts/tools/%E7%BC%96%E7%A0%81/","summary":"请帮我分析一段代码，代码如下： 1 2 3 4 5 6 with open(filename, \u0026#39;rb\u0026#39;) as fp: ff=fp.read() # print(ff) hexstr = binascii.b2a_hex(ff).decode() print(hexstr) ff 是我读取到的内容，直接打印 ff 会得到 二进制数据，通过 binascii.b2a_hex(ff).decode() 会得到十六进制字符串","title":"编码"},{"content":"VScode 常用插件 一、普适\nChinese (Simplified) (简体中文) Language Pack for Visu\n为 VS Code提供本地化界面\n二、Python相关\nPython\n三、前端开发\nhttps://blog.csdn.net/weixin_43248785/article/details/105095440\nopen in browser\n这允许您在默认浏览器或应用程序中打开当前文件。\n各种快捷键 https://zhuanlan.zhihu.com/p/44044896\n新建窗口：ctrl + shift + n 回到顶部：ctrl + home better comment\nBetter Comments 可在注释标识后插入特殊符号，从而更改注释颜色，不同符号对应的颜色如下\n! red ? Blue *Green ^Yellow \u0026amp;Pink ~Purple todo Muscl 设置自动保存代码\n问题：运行代码时，发现运行的还是修改前的代码，解决可以通过 ctrl+s 手动保存，但有点麻烦\n解决：VSCode 左下角齿轮 设置 -\u0026gt; 搜索 Auto Save\n四个选项\noff 关闭 afterDelay 多少毫秒后自动保存 onFocusChange 编辑器失去焦点时自动保存。也就是鼠标在编辑器之外的区域按下左键才会保存 onWindowsChange 窗口失去焦点时，自动保存。即鼠标在 VScode 软件之外的界面按下左键才会保存。 一般使用 afterDelay，选用 100 ms 即可，相当于输入代码实时保存了。\nvue 与 前端三件套 的区别：\nVue 是一个框架，而前端三件套是一组技术，由 HTML、CSS 和 JavaScript 组成。\nVue 是一个用于构建用户界面的 JavaScript 框架，它提供了一组可重用的组件，可以帮助开发者更快地构建 Web 应用程序。而前端三件套则是一组技术，分别用于构建网页的样式、结构和行为。\nVue 具有更强大的模板功能，可以帮助开发者更好地管理数据，而前端三件套则没有这样的功能。\nvue的自动化构建工具是node.js帮我们做的，这就是我们为什么要下载node的原因。\nvue 安装及其环境配置 https://blog.csdn.net/dream_summer/article/details/108867317 https://blog.csdn.net/weixin_44431812/article/details/122270467?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-122270467-blog-103855188.235^v38^pc_relevant_default_base\u0026amp;spm=1001.2101.3001.4242.1\u0026amp;utm_relevant_index=3 安装 Node.js 一、安装 node.js， https://nodejs.org/en/download。由于 Node.js 中默认安装了 npm，所以无需额外配置即可在全局命令中使用 npm，测试是否安装成功，输入 node -v 与 npm -v 查看版本信息。\nC:\\Users\\wangkai1\u0026gt;node -v v18.17.1\nC:\\Users\\wangkai1\u0026gt;npm -v 9.6.7\n二、配置默认安装目录和缓存目录\n说明：这里的环境配置主要配置的是npm安装的全局模块所在的路径，以及缓存cache的路径，之所以要配置，是因为以后在执行类似：npm install express [-g] （后面的可选参数-g，g代表global全局安装的意思）的安装语句时，会将安装的模块安装到【C:\\Users\\用户名\\AppData\\Roaming\\npm】路径中，占C盘空间。\nC:\\Users\\wangkai1\u0026gt;npm list -global npm ERR! code ENOENT npm ERR! syscall lstat npm ERR! path C:\\Users\\wangkai1\\AppData\\Roaming\\npm npm ERR! errno -4058 npm ERR! enoent ENOENT: no such file or directory, lstat \u0026lsquo;C:\\Users\\wangkai1\\AppData\\Roaming\\npm\u0026rsquo; npm ERR! enoent This is related to npm not being able to find a file. npm ERR! enoent\nnpm ERR! A complete log of this run can be found in: C:\\Users\\wangkai1\\AppData\\Local\\npm-cache_logs\\2023-09-03T09_13_25_845Z-debug-0.log\n原因未知。\n在安装目录下，新建文件夹 node_cache 和 node_global，然后执行命令，将npm的全局模块目录和缓存目录配置到我们刚才创建的那两个目录：\nC:\\Users\\wangkai1\u0026gt;npm config set prefix \u0026ldquo;D:\\install_location\\node_wk\\node_global\u0026rdquo;\nC:\\Users\\wangkai1\u0026gt;npm config set cache \u0026ldquo;D:\\install_location\\node_wk\\node_cache\u0026rdquo;\nnpm config get prefix查看npm全局安装包保存路径 npm config get cache查看npm装包缓存路径\n现在再输入 npm list -global 就正常了\nC:\\Users\\wangkai1\u0026gt;npm list -global D:\\install_location\\node_wk\\node_global `\u0026ndash; (empty)\nnpm config list查看所有npm 配置\nC:\\Users\\wangkai1\u0026gt;npm config list ; \u0026ldquo;builtin\u0026rdquo; config from D:\\install_location\\node_wk\\node_modules\\npm\\npmrc\n; prefix = \u0026ldquo;C:\\Users\\wangkai1\\AppData\\Roaming\\npm\u0026rdquo; ; overridden by user\n; \u0026ldquo;user\u0026rdquo; config from C:\\Users\\wangkai1.npmrc\ncache = \u0026ldquo;D:\\install_location\\node_wk\\node_cache\u0026rdquo; prefix = \u0026ldquo;D:\\install_location\\node_wk\\node_global\u0026rdquo;\n; node bin location = D:\\install_location\\node_wk\\node.exe ; node version = v18.17.1 ; npm local prefix = C:\\Users\\wangkai1 ; npm version = 9.6.7 ; cwd = C:\\Users\\wangkai1 ; HOME = C:\\Users\\wangkai1 ; Run npm config ls -l to show all defaults.\n三、Node.js 环境配置\n首先，我的安装路径是：D:\\install_location\\node_wk\n系统变量新增，变量名：NODE_PATH，变量值：D:\\install_location\\node_wk\\node_global\\node_modules 系统变量的 path 下，新建 node 的路径，（我打开查看已经有了，可能是我的 node 版本较新） 设置了全局安装目录后，将用户变量 -\u0026gt; path 下的 npm 修改为 D:\\Program Files\\nodejs\\node_global，我这里具体是 将 “C:\\Users\\wangkai1\\AppData\\Roaming\\npm” 修改为 “D:\\install_location\\node_wk\\node_global” 四、配置淘宝镜像源\n先查看当前的下载源，registry 是注册表的意思\nC:\\Users\\wangkai1\u0026gt;npm config get registry https://registry.npmjs.org/\n目前是国外站点，将npm的模块下载仓库从默认的国外站点改为国内的站点，这样下载模块的速度才能比较快，现在用的都是淘宝镜像源（https://registry.npm.taobao.org），使用淘宝镜像源有两种方式：临时使用和永久使用\n临时使用：\n1 npm --registry https://registry.npm.taobao.org install cluster 这个代码就是只在安装cluster的使用淘宝镜像下载，每次安装一个模块都用挺长的代码，比较繁琐，所以推荐第二种方式。\n永久使用：\n两种配置选择，一是直接修改npm命令的仓库地址为淘宝镜像源，另一种是安装cnpm命令。\n第一种:直接修改npm的默认配置\n1 npm config set registry https://registry.npm.taobao.org 然后用 get 进行验证\n1 2 C:\\Users\\wangkai1\u0026gt;npm config get registry https://registry.npm.taobao.org 配置成功\n第二种是 安装 cnpm，跳过\nnpm 结束\n安装 vue 及 脚手架 一、安装 vue.js\n1 npm install vue -g`或者`cnpm install vue -g 其中-g是全局安装，指安装到global全局目录去\n遇到报错：\nC:\\Users\\wangkai1\u0026gt;npm install vue -g npm ERR! code EPERM npm ERR! syscall mkdir npm ERR! path D:\\install_location\\node_wk\\node_cache_cacache npm ERR! errno -4048 npm ERR! Error: EPERM: operation not permitted, mkdir \u0026lsquo;D:\\install_location\\node_wk\\node_cache_cacache\u0026rsquo; npm ERR! [Error: EPERM: operation not permitted, mkdir \u0026lsquo;D:\\install_location\\node_wk\\node_cache_cacache\u0026rsquo;] { npm ERR! errno: -4048, npm ERR! code: \u0026lsquo;EPERM\u0026rsquo;, npm ERR! syscall: \u0026lsquo;mkdir\u0026rsquo;, npm ERR! path: \u0026lsquo;D:\\install_location\\node_wk\\node_cache\\_cacache\u0026rsquo;, npm ERR! requiredBy: \u0026lsquo;.\u0026rsquo; npm ERR! } npm ERR! npm ERR! The operation was rejected by your operating system. npm ERR! It\u0026rsquo;s possible that the file was already in use (by a text editor or antivirus), npm ERR! or that you lack permissions to access it. npm ERR! npm ERR! If you believe this might be a permissions issue, please double-check the npm ERR! permissions of the file and its containing directories, or try running npm ERR! the command again as root/Administrator.\nnpm ERR! Log files were not written due to an error writing to the directory: D:\\install_location\\node_wk\\node_cache_logs npm ERR! You can rerun the command with --loglevel=verbose to see the logs in your terminal\nnpm安装报错（npm ERR! code EPERM npm ERR! syscall mkdir npm ERR! path C:\\Program Files\\nodejs\\node_ca\u0026hellip;）_婷婷心慌的博客-CSDN博客\n评论区说是权限问题，管理员身份运行cmd即可\n删除 用户\\wangkai1 下的 .npmrc 文件（隐藏）\n可以了。\n1 2 3 4 5 6 7 8 9 10 11 C:\\Users\\wangkai1\u0026gt;npm install vue -g added 20 packages in 42s 2 packages are looking for funding run `npm fund` for details npm notice npm notice New major version of npm available! 9.6.7 -\u0026gt; 10.0.0 npm notice Changelog: https://github.com/npm/cli/releases/tag/v10.0.0 npm notice Run npm install -g npm@10.0.0 to update! npm notice 查看安装的vue信息：npm info vue 或者cnpm info vue\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 C:\\Users\\wangkai1\u0026gt;npm info vue vue@3.3.4 | MIT | deps: 5 | versions: 445 The progressive JavaScript framework for building modern web UI. https://github.com/vuejs/core/tree/main/packages/vue#readme keywords: vue dist .tarball: https://registry.npmjs.org/vue/-/vue-3.3.4.tgz .shasum: 8ed945d3873667df1d0fcf3b2463ada028f88bd6 .integrity: sha512-VTyEYn3yvIeY1Py0WaYGZsXnz3y5UnGi62GjVEqvEGPl6nxbOrCXbVOTQWBEJUqAyTUk2uJ5JLVnYJ6ZzGbrSw== .unpackedSize: 2.0 MB dependencies: @vue/compiler-dom: 3.3.4 @vue/runtime-dom: 3.3.4 @vue/shared: 3.3.4 @vue/compiler-sfc: 3.3.4 @vue/server-renderer: 3.3.4 maintainers: - yyx990803 \u0026lt;yyx990803@gmail.com\u0026gt; - posva \u0026lt;posva13@gmail.com\u0026gt; dist-tags: alpha: 3.3.0-alpha.13 latest: 3.3.4 v2-alpha: 2.7.0-alpha.12 beta: 3.3.0-beta.5 legacy: 2.6.14 v2-beta: 2.7.0-beta.8 csp: 1.0.28-csp next: 3.2.36 v2-latest: 2.7.14 published 3 months ago by yyx990803 \u0026lt;yyx990803@gmail.com\u0026gt; 查看 vue 版本\n1 2 3 4 5 6 7 8 9 10 C:\\Users\\wangkai1\u0026gt;npm list vue C:\\Users\\wangkai1 `-- (empty) C:\\Users\\wangkai1\u0026gt;npm list vue -g C:\\Users\\wangkai1\\AppData\\Roaming\\npm `-- vue@3.3.4 `-- @vue/server-renderer@3.3.4 `-- vue@3.3.4 deduped 二、安装 webpack 模板\nnpm install webpack -g\n1 2 3 4 5 6 C:\\Users\\wangkai1\u0026gt;npm install webpack -g added 77 packages in 1m 9 packages are looking for funding run `npm fund` for details webpack 4x以上，webpack将命令相关的内容都放到了webpack-cli， 所以还需要安装webpack-cli：npm install --global webpack-cli， 安装成功后可使用webpack -v查看版本号。\n1 2 3 4 5 6 C:\\Users\\wangkai1\u0026gt;npm install --global webpack-cli added 117 packages in 51s 15 packages are looking for funding run `npm fund` for details 不行，\n1 2 3 C:\\Users\\wangkai1\u0026gt;webpack -v \u0026#39;webpack\u0026#39; 不是内部或外部命令，也不是可运行的程序 或批处理文件。 找到 下载 npm 根路径\n1 2 C:\\Users\\wangkai1\u0026gt;npm root -g C:\\Users\\wangkai1\\AppData\\Roaming\\npm\\node_modules 哎呀，都下载都 c 盘里面了，什么情况。\n先不管了，\nhttps://blog.csdn.net/qq_39742704/article/details/120251085\n解决方案：将根路径 去掉 node_module，添加到系统变量的 path。\n1 2 3 4 5 6 7 8 9 10 11 12 C:\\Users\\wangkai1\u0026gt;webpack -v System: OS: Windows 10 10.0.19045 CPU: (16) x64 AMD Ryzen 7 6800H with Radeon Graphics Memory: 7.56 GB / 13.69 GB Binaries: Node: 18.17.1 - D:\\install_location\\node_wk\\node.EXE npm: 9.6.7 - D:\\install_location\\node_wk\\npm.CMD Browsers: Edge: Spartan (44.19041.1266.0), Chromium (116.0.1938.69) Internet Explorer: 11.0.19041.1566 三、安装脚手架 vue-cli\nnpm install vue-cli -g\n使用 vue --version 检查版本是否正确，也可以 vue -V，但 vue -v 不可以\n1 2 C:\\Users\\wangkai1\u0026gt;vue --version 2.9.6 然后顺手安上 vue-router，npm install -g vue-router\n哎，这里和教程不一样了，教程是安装在了D盘，我全安装在了C盘，不知道是哪里出了问题。\n四、vue-cli 创建 vue 项目\n1、创建项目（最好在cd到D盘的某个位置，即项目的路径，否则项目会新建在C:\\Users\\Administrator\\，也可以直接在想要的项目路径下输入cmd）vue init webpack 项目名\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 D:\\study_front\u0026gt;vue init webpack vue_demo ? Project name vue_demo ? Project description A Vue.js project ? Vue build standalone ? Install vue-router? Yes ? Use ESLint to lint your code? No ? Set up unit tests No ? Setup e2e tests with Nightwatch? No ? Should we run `npm install` for you after the project has been created? (recommended) npm vue-cli · Generated \u0026#34;vue_demo\u0026#34;. # Installing project dependencies ... # ======================== npm WARN deprecated consolidate@0.14.5: Please upgrade to consolidate v1.0.0+ as it has been modernized with several long-awaited fixes implemented. Maintenance is supported by Forward Email at https://forwardemail.net ; follow/watch https://github.com/ladjs/consolidate for updates and release changelog npm WARN deprecated stable@0.1.8: Modern JS already guarantees Array#sort() is a stable sort, so this library is deprecated. See the compatibility table on MDN: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#browser_compatibility npm WARN deprecated uuid@3.4.0: Please upgrade to version 7 or higher. Older versions may use Math.random() in certain circumstances, which is known to be problematic. See https://v8.dev/blog/math-random for details. npm WARN deprecated source-map-url@0.4.1: See https://github.com/lydell/source-map-url#deprecated npm WARN deprecated urix@0.1.0: Please see https://github.com/lydell/urix#deprecated npm WARN deprecated resolve-url@0.2.1: https://github.com/lydell/resolve-url#deprecated npm WARN deprecated source-map-resolve@0.5.3: See https://github.com/lydell/source-map-resolve#deprecated npm WARN deprecated bfj-node4@5.3.1: Switch to the `bfj` package for fixes and new features! npm WARN deprecated acorn-dynamic-import@2.0.2: This is probably built in to whatever tool you\u0026#39;re using. If you still need it... idk npm WARN deprecated flatten@1.0.3: flatten is deprecated in favor of utility frameworks such as lodash. npm WARN deprecated svgo@0.7.2: This SVGO version is no longer supported. Upgrade to v2.x.x. npm WARN deprecated uglify-es@3.3.9: support for ECMAScript is superseded by `uglify-js` as of v3.13.0 npm WARN deprecated browserslist@2.11.3: Browserslist 2 could fail on reading Browserslist \u0026gt;3.0 config used in other tools. npm WARN deprecated html-webpack-plugin@2.30.1: out of support npm WARN deprecated core-js@2.6.12: core-js@\u0026lt;3.23.3 is no longer maintained and not recommended for usage due to the number of issues. Because of the V8 engine whims, feature detection in old core-js versions could cause a slowdown up to 100x even if nothing is polyfilled. Some versions have web compatibility issues. Please, upgrade your dependencies to the actual version of core-js. npm WARN deprecated extract-text-webpack-plugin@3.0.2: Deprecated. Please use https://github.com/webpack-contrib/mini-css-extract-plugin npm WARN deprecated svgo@1.3.2: This SVGO version is no longer supported. Upgrade to v2.x.x. npm WARN deprecated chokidar@2.1.8: Chokidar 2 does not receive security updates since 2019. Upgrade to chokidar 3 with 15x fewer dependencies npm WARN deprecated browserslist@1.7.7: Browserslist 2 could fail on reading Browserslist \u0026gt;3.0 config used in other tools. npm WARN deprecated browserslist@1.7.7: Browserslist 2 could fail on reading Browserslist \u0026gt;3.0 config used in other tools. npm WARN deprecated browserslist@1.7.7: Browserslist 2 could fail on reading Browserslist \u0026gt;3.0 config used in other tools. npm WARN deprecated chokidar@2.1.8: Chokidar 2 does not receive security updates since 2019. Upgrade to chokidar 3 with 15x fewer dependencies added 1313 packages, and audited 1314 packages in 4m 90 packages are looking for funding run `npm fund` for details 86 vulnerabilities (1 low, 49 moderate, 29 high, 7 critical) To address issues that do not require attention, run: npm audit fix To address all issues (including breaking changes), run: npm audit fix --force Run `npm audit` for details. # Project initialization finished! # ======================== To get started: cd vue_demo npm run dev Documentation can be found at https://vuejs-templates.github.io/webpack 进入到项目目录下，执行 npm run dev\n1 2 3 4 5 6 7 8 9 10 11 12 13 D:\\study_front\\vue_demo\u0026gt;npm run dev \u0026gt; vue_demo@1.0.0 dev \u0026gt; webpack-dev-server --inline --progress --config build/webpack.dev.conf.js (node:10000) [DEP0111] DeprecationWarning: Access to process.binding(\u0026#39;http_parser\u0026#39;) is deprecated. (Use `node --trace-deprecation ...` to show where the warning was created) 12% building modules 22/27 modules 5 active ...0!D:\\study_front\\vue_demo\\src\\App.vue{ parser: \u0026#34;babylon\u0026#34; } is deprecated; we now treat it as { parser: \u0026#34;babel\u0026#34; }. 95% emitting DONE Compiled successfully in 17440ms 19:20:25 I Your application is running here: http://localhost:8080 访问这个地址：http://localhost:8080/#/ 即可\n成功啦！\nnpm run dev 和 npm run server https://blog.csdn.net/weixin_44152565/article/details/111355262\ncd cmd\ncd /d D: 可以切换到D盘\n每次只能打开一个编辑窗口 成功解决VScode每次只能打开一个文件，即只能打开一个编辑窗口。_旋转的油纸伞的博客-CSDN博客\n文件 \u0026ndash;\u0026gt; 首选项 \u0026ndash;\u0026gt; 设置 \u0026ndash;\u0026gt; 工作台 \u0026ndash;\u0026gt; 编辑管理 \u0026ndash;\u0026gt; 取消勾选Enable Preview\n后端：\n","permalink":"https://wangkai26.github.io/posts/tools/vscode/","summary":"VScode 常用插件 一、普适 Chinese (Simplified) (简体中文) Language Pack for Visu 为 VS Code提供本地化界面 二、Python相关 Python 三、前端开发 https://blog.csdn.net/weixin_43248785/article/details/105095440 open in browser 这允许您在默认浏览器或应用程序","title":"Vscode"},{"content":"报错：\nE325: ATTENTION Found a swap file by the name \u0026ldquo;/var/tmp/hello.sh.swp\u0026rdquo; owned by: ubuntu dated: Fri Oct 04 12:15:26 2024 file name: /data/exer_sh/hello.sh modified: no user name: ubuntu host name: VM-12-2-ubuntu process ID: 3404503 (STILL RUNNING) While opening file \u0026ldquo;hello.sh\u0026rdquo; CANNOT BE FOUND (1) Another program may be editing the same file. If this is the case, be careful not to end up with two different instances of the same file when making changes. Quit, or continue with caution. (2) An edit session for this file crashed. If this is the case, use \u0026ldquo;:recover\u0026rdquo; or \u0026ldquo;vim -r hello.sh\u0026rdquo; to recover the changes (see \u0026ldquo;:help recovery\u0026rdquo;). If you did this already, delete the swap file \u0026ldquo;/var/tmp/hello.sh.swp\u0026rdquo; to avoid this message.\n第一个 shell 脚本\n1 vim hello.sh 第一行井号开头的内容代表 使用 zsh 执行命令\n1 2 3 4 5 6 #!/bin/zsh echo \u0026#34;hello,world!\u0026#34; date pwd whoami echo \u0026#34;end\u0026#34; 写完之后，使用 chmod 命令给文件添加执行权限，否则执行时会遇到报错：zsh: permission denied\n1 chmod a+x hello.sh 切换根用户执行脚本文件，sudo su\n执行结果：\n1 2 3 4 5 6 VM-12-2-ubuntu# ./hello.sh hello,world! Sat Oct 5 01:35:58 PM CST 2024 /data/exer_sh root end 符合预期\n这就是一个最简单的脚本的执行过程\nshell 脚本支持分支、条件判断 和 循环等编程语言中才有的特性，也可以定义函数和变量，可以调用系统命令以及其他程序，还可以进行文件读写等操作，是非常强大的工具。\n","permalink":"https://wangkai26.github.io/posts/tech/linux/vim/","summary":"报错： E325: ATTENTION Found a swap file by the name \u0026ldquo;/var/tmp/hello.sh.swp\u0026rdquo; owned by: ubuntu dated: Fri Oct 04 12:15:26 2024 file name: /data/exer_sh/hello.sh modified: no user name: ubuntu host name: VM-12-2-ubuntu process ID: 3404503 (STILL RUNNING) While opening file \u0026ldquo;hello.sh\u0026rdquo; CANNOT BE FOUND (1) Another program may be editing the same file. If this is the case, be careful not to end up with two different instances of","title":"Vim"},{"content":"tmux cd # 可快速切换到当前用户根目录下\ntmux\n安装 tmux 1 sudo apt-get install tmux 新建 tmux 终端 tmux 常用命令 1 2 3 4 5 6 7 8 9 10 11 12 13 #列出创建的 tmux 进程 tmux list-sessions # 创建新的 session,创建后会自动进入该 tmux 的 session 下 tmux new -s session_name # 等价于 tmux new-session -s session_name # 回到之前某个会话 tmux a -t session_name # 退出到主界面 tmux det ctrl + b 若创建了多个会话\n1 先按ctrl+b ，再按s，然后就可以在会话间选择其中一个，按enter进入。 查看会话里的历史信息记录\n1 2 先按ctrl+b，然后按Page Up ，Page Down # 按 q 退出历史信息查看模式 按 c\n切换到不同的 tmux session\ntmux 终端下，按下 ctrl + b，然后再按 d，会将该终端和 ssh 会话分离，回到\n回到某个 session\ntmux a -t session_name\n可以先关掉终端，过一会儿再回来看 ouput 是否有对应文件，\n删除 session\ntmux kill-session -t session_name\n使用tmux时，有一个问题，我在普通ssh终端，上下划动鼠标滚轮时，能够看到之前的数据，但在 tmux 内，我划动滚轮时，会在命令行切换之前输入过的命令，我该如何恢复\n在 tmux 中，滚动鼠标滚轮时默认情况下是用于滚动 tmux 的缓冲区而不是终端的滚动。如果您想在 tmux 中恢复使用滚轮滚动终端的功能，您可以进行以下配置：\n打开 tmux 配置文件（通常是 ~/.tmux.conf）： 1 vi ~/.tmux.conf 在配置文件中添加以下行： 1 set -g mouse on 保存并关闭文件。 重新加载 tmux 配置： 1 tmux source-file ~/.tmux.conf 现在，您应该能够在 tmux 中使用鼠标滚轮来滚动终端，并查看之前的输出。\n请注意，某些终端模拟器可能需要额外的配置才能支持鼠标滚轮功能。如果上述配置不起作用，请确保您的终端模拟器已启用了鼠标滚轮支持，并查阅相应终端模拟器的文档以获取更多信息。\n参考链接：\ntmux：https://blog.csdn.net/m0_65266030/article/details/135510327\nhttps://www.cnblogs.com/wanglouxiaozi/p/14813284.html\n终端复用器Tmux（一个让你彻底放弃 nohup/\u0026amp; 命令的工具）\nhttps://blog.csdn.net/m0_65266030/article/details/135510327\nhttps://blog.csdn.net/qq_18677445/article/details/139146070\n终端复用器：https://www.cnblogs.com/wanglouxiaozi/p/14813284.html\n还有一个可以让命令在后台持续运行，nohup\nhttps://www.ruanyifeng.com/blog/2019/10/tmux.html\n","permalink":"https://wangkai26.github.io/posts/tech/linux/linux%E4%B9%8Btmux/","summary":"tmux cd # 可快速切换到当前用户根目录下 tmux 安装 tmux 1 sudo apt-get install tmux 新建 tmux 终端 tmux 常用命令 1 2 3 4 5 6 7 8 9 10 11 12 13 #列出创建的 tmux 进程 tmux list-sessions # 创建新的 sessi","title":"Linux之tmux"},{"content":"本地环境：win10 + VSCode，使用 database 插件，ssh 连接服务器\n为了配置这个网上看起来比较漂亮的终端，踩了一些坑，来来回回搞了快 5 个小时才搞好，这里分享下经验。\n主要流程：\n安装zsh 安装 p10k 安装 Oh-My-Zsh 安装 Nerd 字体 配置文件 zshrc 配置 p10k 一、安装zsh 可以输入 echo $SHELL 查看当前使用的 shell\n1 2 ubuntu@VM-12-2-ubuntu:~$ echo $SHELL /bin/bash cat /etc/shells 查看支持的shell\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 ubuntu@VM-12-2-ubuntu:~$ cat /etc/shells # /etc/shells: valid login shells /bin/sh /bin/bash /usr/bin/bash /bin/rbash /usr/bin/rbash /usr/bin/sh /bin/dash /usr/bin/dash /usr/bin/tmux /usr/bin/screen /bin/zsh /usr/bin/zsh 因为我已经安装了 zsh，所以已经有了 zsh\nzsh 的安装\n1 sudo apt install wget git curl vim -y 安装后，会有系统内核升级的提示，一路按回车\n安装好后后再使用 cat 查看系统支持的shell，会看到比刚才多了 zsh，这样 zsh 的安装就完成了\n然后，将系统默认shell 切换为 zsh\n1 chsh -s $(which zsh) 二、安装 p10k 1 git clone --depth=1 https://github.com/romkatv/powerlevel10k.git ~/powerlevel10k 国内用户可以放心使用下面 http://gitee.com 上的官方镜像加速下载.\n1 git clone --depth=1 https://gitee.com/romkatv/powerlevel10k.git ~/powerlevel10k 推荐同时下载另外两个插件\n1 2 3 4 # zsh-autosuggestions自动提示插件 git clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions # zsh-syntax-highlighting语法高亮插件 git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting 三、安装 Oh-My-Zsh 执行语句；\n1 git clone --depth=1 https://github.com/romkatv/powerlevel10k.git ${ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom}/themes/powerlevel10k 中国用户可以使用 http://gitee.com 上的官方镜像加速下载.\n1 git clone --depth=1 https://gitee.com/romkatv/powerlevel10k.git ${ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom}/themes/powerlevel10k 四、安装 Nerd 字体 由于我是在 win10 系统下，使用 VSCode 连接服务器的，我在电脑安装并在 VSCode 配置字体就可以了\n如果不安装，会类似下图，有未知符号\nPowerlevel10k不需要自定义字体，但如果有的话可以利用它们。它可以很好地与Nerd Fonts, Source Code Pro, Font Awesome, Powerline，甚至默认的系统字体配合使用。只有在使用Nerd字体时，才能使用完整的样式选项。推荐字体:为Powerlevel10k修补的Meslo Nerd字体。\n直接点击下面四个链接下载 ttf 文件并安装，官方链接\nMesloLGS NF Regular.ttf MesloLGS NF Bold.ttf MesloLGS NF Italic.ttf MesloLGS NF Bold Italic.ttf 安装好后，在 VSCode 设置中输入 editor.font 找到 Font Family，设置为 MesloLGS NF 即可。\n2024/9/24 更新，修改 Font Family 会一起修改编辑器中代码的字体，可以在设置中输入 terminal.integrated.font，设为 MesloLGS NF，同样会生效\n五、配置文件 zshrc 修改以下两点即可，启动插件和主题，git 是默认启用的，主要添加后面两个\n1 2 3 4 5 6 7 8 9 # 修改主题 ZSH_THEME=\u0026#34;powerlevel10k/powerlevel10k\u0026#34; # 启用插件 plugins=( git zsh-autosuggestions zsh-syntax-highlighting ) 六、配置 p10k 输入以下命令即可配置 p10k，\n1 p10k configure 这里有一个很大的坑，我配置过程中，总是跳过最关键的 prompt style 这一步，导致我无法设置我最想要的 rainbow 效果\n需要终端输入以下命令，将终端配置支持 24 位真彩色（这里我浪费了很多时间）\n1 export TERM=\u0026#34;xterm-256color\u0026#34; 然后再执行 p10k configure，就会有 prompt style 选项了。\n如果想重新配置，再次输入下面命令即可\n1 p10k configure 到此为止终于完成了！\n参考链接：\nromkatv/powerlevel10k: A Zsh theme (github.com) 在windows中ohmyzsh 的powerlevel10k主题及插件推荐_powerlevel10k 字体下载-CSDN博客 利用zsh+oh-my-zsh+powerlevel10k为Linux终端配置一个漂亮的shell_zsh powerlevel10k-CSDN博客 ","permalink":"https://wangkai26.github.io/posts/tech/linux/zsh/","summary":"本地环境：win10 + VSCode，使用 database 插件，ssh 连接服务器 为了配置这个网上看起来比较漂亮的终端，踩了一些坑，来来回回搞了快 5 个小时才搞","title":"VSCode连接linux,配置zsh+p10k终端,踩坑经验"},{"content":" date: 2024-02-02T04:14:54-08:00 draft: false params: author: kai title: hugo使用title weight: 10\n验证是否安装完成：\n输入 hguo version，检查是否有如下打印信息\n1 2 D:\\github-kai\\kai_blog\u0026gt;hugo version hugo v0.131.0-bfbee17932ff24009008aa94cdd75c0c41f59279 windows/amd64 BuildDate=2024-08-02T09:03:48Z VendorInfo=gohugoio 快速运行流程：\n在 quickstart 目录中为您的项目创建 目录结构 hugo new site quickstart\n将当前目录更改为项目的根目录。cd quickstart\n进入 themes 目录，下载主题，如 papermod，git clone https://github.com/adityatelange/hugo-PaperMod.git\n回到主目录启动 Hugo 启动本地服务器并生成站点内容，hugo server -D\n重要链接：\nFeatures · adityatelange/hugo-PaperMod Wiki (github.com) [置顶] hugo博客搭建 | PaperMod主题 | Sulv\u0026rsquo;s Blog (sulvblog.cn) [golang][hugo]使用Hugo搭建静态站点-腾讯云开发者社区-腾讯云 (tencent.com)\nHugo | 一起动手搭建个人博客吧 | 小球飞鱼 (mantyke.icu)\nhttps://blog.csdn.net/p_function/article/details/103842298\nhttps://www.emojiall.com/zh-hans/all-emojis\nhttps://bore.vip/archives/ca21a352/index.html https://www.shaohanyun.top/posts/env/blog_build2/ https://dvel.me/posts/hugo-papermod-config/#markdown-%e6%b8%b2%e6%9f%93%e9%a3%8e%e6%a0%bc\nHugo 与 github page 关联 https://ratmomo.github.io/p/2024/06/%E4%BD%BF%E7%94%A8-hugo--github-pages-%E9%83%A8%E7%BD%B2%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/\n安装hugo 创建项目\nHugo new PS D:\\github-kai\u0026gt; hugo new site kai-blog Congratulations! Your new Hugo site was created in D:\\github-kai\\kai-blog.\nJust a few more steps\u0026hellip;\nChange the current directory to D:\\github-kai\\kai-blog. Create or install a theme: Create a new theme with the command \u0026ldquo;hugo new theme \u0026rdquo; Or, install a theme from https://themes.gohugo.io/ Edit hugo.toml, setting the \u0026ldquo;theme\u0026rdquo; property to the theme name. Create new content with the command \u0026ldquo;hugo new content \u0026lt;FILENAME\u0026gt;.\u0026rdquo;. Start the embedded web server with the command \u0026ldquo;hugo server \u0026ndash;buildDrafts\u0026rdquo;. See documentation at https://gohugo.io/.\n建好后，有以下内容：\nArchetypes 有 default.md Assets 空 Content 空 Data 空 i18n 空 Layouts 空 Static 空 Themes 空 hugo.toml 1kb 参考教程：\nhttps://www.sulvblog.cn/ https://www.sulvblog.cn/posts/blog/build_hugo/#6%e5%90%af%e5%8a%a8%e5%8d%9a%e5%ae%a2 配置文件 - 基本 注意：没有配置 theme 时，本地运行，页面会是：Page Not Found\n默认的配置文件为根目录下 hugo.toml 文件\n默认内容：\n1 2 3 4 5 6 7 8 baseURL = \u0026#39;https://example.org/\u0026#39; languageCode = \u0026#39;en-us\u0026#39; title = \u0026#39;ABC Widgets, Inc.\u0026#39; [params] subtitle = \u0026#39;The Best Widgets on Earth\u0026#39; [params.contact] email = \u0026#39;info@example.org\u0026#39; phone = \u0026#39;+1 202-555-1212\u0026#39; 查看默认加载路径： Hugo会按优先级顺序尝试加载以下配置文件，你可以根据这些默认路径检查配置文件：\nconfig.yaml config.toml config.json 如果你有多个配置文件（例如hugo.yaml和hugo.toml），Hugo会根据文件类型加载默认的config.yaml、config.toml或config.json。确保你命名的配置文件是config.yaml而不是hugo.yaml。\n因为不习惯 toml 的语法，所以我删除了原先的 hugo.toml，新建了文件 config.yaml\n1 2 3 4 baseURL: https://example.org/ languageCode: en-us title: My New Hugo Site. theme: hugo-PaperMod # 主题名字，和themes文件夹下的一致 配置文件 - 进阶 站点导航菜单 menu 在 Hugo 中，menu配置项用于定义站点导航菜单，identifier是每个菜单条目的一个唯一标识符。\nPaperMod Features · adityatelange/hugo-PaperMod Wiki (github.com)\n时间轴设置\narchives，注意设置 layout: \u0026ldquo;archives\u0026rdquo; ，这是最核心的\n文件头部规范 1 2 3 4 5 6 7 +++ Categories =[\u0026#34;github\u0026#34;] Tags = [\u0026#34;github\u0026#34;, \u0026#34;开发者\u0026#34;, \u0026#34;go\u0026#34;] date = \u0026#34;2019-12-12T18:20:42+08:00\u0026#34; title = \u0026#34;hugo搭建github博客过程\u0026#34; description = \u0026#34;landv\u0026#34; +++ 1.title 文章名称 2.description 文章详细介绍 3.tag 标签 4.categories 文章分类 _index 作用 如果在文件夹下不生成 _index.md 文件\n那进入主页的 posts 可以直接看到文章标题\n但在主页点击按钮会进入 404 界面，因为无法找到 url\n1 2 3 4 5 6 7 buttons: - name: 👨🏻‍💻技术 url: posts/tech - name: 📕阅读 url: posts/read - name: 🏖生活 url: posts/life 只要创建了 _index.md 文件，甚至不需要任何内容，再点击按钮就可以到文章界面\n常用命令 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #使用方法: hugo hugo [flags] hugo [command] hugo [command] [flags] #查看版本 hugo version #版本和环境详细信息 hugo env #创建新站点 hugo new site \u0026#34;$mysite\u0026#34; #创建文章 hugo new index.md 在content/文件夹可以看到，此时多了一个markdown格式的文件index.md，打开文件可以看到时间和文件名等信息已经自动加到文件开头，包括创建时间，页面名，是否为草稿等。 #编译生成静态文件，Hugo将编译所有文件并输出到public目录 hugo #编译生成静态文件并启动web服务 hugo server 常用参数：\n1 2 3 4 5 6 7 8 9 10 11 --bind=\u0026#34;127.0.0.1\u0026#34; 服务监听IP地址； -p, --port=1313 服务监听端口； -w, --watch[=true] 监听站点目录，发现文件变更自动编译； -D, --buildDrafts 包括被标记为draft的文章； -E, --buildExpired 包括已过期的文章； -F, --buildFuture 包括将在未来发布的文章； -b, --baseURL=\u0026#34;www.datals.com\u0026#34; 服务监听域名； --log[=false]: 开启日志； --logFile=\u0026#34;/var/log/hugo.log\u0026#34;: log输出路径； -t, --theme=\u0026#34;\u0026#34; 指定主题； -v, --verbose[=false]: 输出详细信息 一些小问题： hugo server 和 hugo server -D 的区别：\nhugo server -D： 这个命令会启动本地服务器并生成站点内容，同时包括所有标记为草稿的文章。也就是说，即使文章还在草稿状态（draft: true），它们也会在本地预览时显示出来。这对于开发和调试非常有用： 总结起来，-D参数的作用是确保包含草稿文章，以便在本地环境中可以预览和测试这些内容。如果你在开发过程中需要查看所有文章（包括草稿），推荐使用hugo server -D。而如果你只关心那些已经不是草稿的内容，可以仅使用hugo server。\n2.profileMode 不生效\nprofileMode 不生效： 解决办法：将其放在 params 内部，\n为什么使用 params 能够解决问题\n约定俗成：Hugo 的设计理念中，把自定义的站点参数统一放在 params 下，是一种约定俗成的做法。这样不仅代码更加清晰，而且也避免了可能的命名冲突。 模板访问：将自定义参数放在 params 下，可以确保 Hugo 能够正确地将这些参数包含在其上下文中，使得它们能够被模板正确访问和渲染。 一致性：统一将所有自定义参数放在 params 下，保证了配置的结构和访问的一致性，使得管理配置更加方便。 报错： defaultContentLanguage: \u0026ldquo;zh\u0026rdquo; # # 设置默认语言为中文\nhugo new a.md\npanic: lang not set\n解决办法，\n将 defaultContentLanguage: \u0026quot;zh\u0026quot; 对应语言设置为和 languageCode 一样，我之前是因为 defaultContentLanguage 为空\n生成文章不展示\n可能是因为 draft 状态为 True，将其修改为 False 就可以啦。\n","permalink":"https://wangkai26.github.io/posts/tech/hugo_custom/basic/","summary":"date: 2024-02-02T04:14:54-08:00 draft: false params: author: kai title: hugo使用title weight: 10 验证是否安装完成： 输入 hguo version，检查是否有如下打印信息 1 2 D:\\github-kai\\kai_blog\u0026gt;hugo version hugo v0.131.0-bfbee17932ff24009008aa94cdd75c0c41f59279 windows/amd64 BuildDate=2024-08-02T09:03:48Z VendorInfo=gohugoio 快速运行流程： 在 quickstart","title":"Basic"},{"content":"","permalink":"https://wangkai26.github.io/posts/tech/mysql/demo3/","summary":"","title":"Demo3"},{"content":"","permalink":"https://wangkai26.github.io/posts/tech/mysql/demo2/","summary":"","title":"Demo2"},{"content":"","permalink":"https://wangkai26.github.io/posts/tech/mysql/demo1/","summary":"","title":"Demo1"},{"content":"nginx 理论知识\n","permalink":"https://wangkai26.github.io/posts/tech/nginx/principles/","summary":"nginx 理论知识","title":"Nginx 理论知识"},{"content":"正则表达式(Regular Expression)是一种文本模式，包括普通字符（例如，a 到 z 之间的字母）和特殊字符（称为\u0026quot;元字符\u0026quot;），可以用来描述和匹配字符串的特定模式。\n正则表达式 ","permalink":"https://wangkai26.github.io/posts/tech/regex/practice/","summary":"正则表达式(Regular Expression)是一种文本模式，包括普通字符（例如，a 到 z 之间的字母）和特殊字符（称为\u0026quot;元字符\u0026q","title":"Practice"},{"content":"正则表达式(Regular Expression)是一种文本模式，包括普通字符（例如，a 到 z 之间的字母）和特殊字符（称为\u0026quot;元字符\u0026quot;），可以用来描述和匹配字符串的特定模式。\n正则表达式 简介：正则表达式(Regular Expression)其实就是一门工具，目的是为了字符串模式匹配，从而实现搜索和替换功能。它是一种用来描述规则的表达式。而它的底层原理也十分简单，就是使用状态机的思想进行模式匹配。大家可以利用regexper.com这个工具很好地可视化自己写的正则表达式:\n修饰符 正则表达式一般被两个斜线包裹起来，后面跟上一些修饰符，如，修饰符含义：\ng 表示 global，即 全局匹配\ni 表示 ignore case，即 忽略大小写\nm 表示 multiline，即 多行匹配\n基本语法-单个和多个字符 \\ 代表转义字符，.、*、[、] 等，如果想要匹配它们本身的话，就需要在前面加一个反斜线来转义一下\n匹配单个字符\n. 在正则表达式中 表示出了换行符之外的任意一个字符\n方括号表示字符的集合，方括号内部可以放 字符、数字 或 其他字符，\n单个字符，如 abc123\n可以使用一个中杠来表示范围。比如 a-z 表示从 a 到 z 的所有小写字母，1-3 代表 1 到 3 的所有数字。\n尖括号表示取反，如：^a-z 代表除了小写字母之外的任意字符，^A-Za-z 代表除了字母之外的任意字符\nnotice：尖角号^只有在方括号内部才表示取反，在方括号外面表示匹配每一行的开头。\n在正则表达式中，经常遇到匹配 数字、字母 或 空白字符这样的场景，如果每次都写方括号，再写一堆字符，会非常繁琐。\n所以，正则表达式提供了一些预定义的字符类，用来匹配常见的字符，如\n\\d 代表数字，作用与 [0-9] 完全一致 \\D 代表非数字，等价于 [^0-9] \\w 代表 数字、字母 或 下划线，等价于 \\W 代表 \\w 取反，数字、字母 或 下划线 之外的任意字符，比如 空白字符 或 一些特殊字符 \\s 代表 空白字符，代表 空格 或者 tab， \\S 代表 \\s 取反，非空白字符 位置和边界匹配 Anchors 常用 ^ 和 $，匹配每行的开头和结尾\n\\b 单词边界，boundary，比如，要找到文本中以 in 开头的字符，可以用 \\bin，那 in 在单词中间 或 结尾，就不会被匹配到，想独立匹配 in 这个单词的话，就在前后都加上 \\b，\n\\b 非单词边界，如 \\bin\\b，只有在单词中间的 in 会被匹配到，而开头、结尾 和 中间的 in 都不会被匹配到\n量词 Quantifiers 量词，顾名思义，就是表示重复次数的\n+ 代表前面的字符 重复了一次或者 多次\n. 代表前面的字符重复了 零次 或者 多次\n? 代表前面的字符重复了 零次 或者 一次\n花括号表示指定的重复次数，比匹配 a 后面有 三个 t 这样的字符串的话，使用 at{3}，花括号中除了使用一个数字表示精确的重复次数外，还可以使用逗号分隔开的两个数字表示一个范围。如 3~5 个 t 的话，使用 at{3,5}。{3,} 表示至少重复了 3 次，\nnotice：正则表达式默认是贪婪匹配的，也就是会匹配尽可能多的字符。（默认情况下，尽可能多地匹配，直到不再满足匹配条件为止）\n与贪婪模式相对的是 非贪婪模式，有时候不需要匹配尽可能多的字符，只需要满足最小的匹配条件就可以了，这时可以在量词后面加一个?，如 at{3,}? 匹配到三个 ? 后就会停止匹配\n分组和引用 Groups 分组可以将多个字符作为一个整体来处理\n最简单的分组用法：比如，想要匹配多个 at，直接使用 at*，会匹配到 attt，使用 (at)* 才会匹配到多个at，如 atatatat，表示 at 出现了多次，只想匹配 at 重复三次，可以使用 (at){3}\n例子2：匹配 pattern 和 Pattern\n可以使用方括号匹配 p 或 P，[pP]attern，还可以使用竖线，代表逻辑或：pattern|Pattern，如果使用 P|pattern，会匹配到 P 或则 pattern，匹配不到 Pattern，不符合需求，这时可以使用分组，将 P 和 p 括起来作为一个分组，然后再加上单词剩余的部分，(P|p)attern 即可。\n使用小括号创建一个分组后，可以捕获这个分组的内容，在后续的处理中也可以引用或者提取这部分内容。如：\n例子3：时间匹配和替换\n要求：将以下时间均修改为 mm-dd-yyyy 的格式\n2024-10-04 2024-10-05 2024-10-078 20240302 2021/54/26\n首先匹配这三种时间格式， 表达式：(\\d{4})[-/.]?(\\d{2})[-/.]?(\\d{2})，三个分组，分别为 年月日\n替换的话，在 VSCode 和 regrex 中使用 $2-$3-$1 即可，其他编程语言也是类似的\n有时，我们只是想要一个分组的功能，但是并不需要捕获这个分组，可以使用问号加一个冒号来表示非捕获分组，如：(\\d{4})[-/.]?(?:\\d{2})[-/.]?(\\d{2})，只有两个分组，分别是 年 和 日\nre.compile 将正则表达式转化为正则对象，生成正则对象，需要和 match、search、findall 搭配使用\n分组另一个常用用法是 引用。\n例子1：想要匹配一些单词，这些单词的第一个字母和最后一个字母必须相同，alibaba 和 tencent 满足该条件，google 不满足。\n可使用分组和引用来实现，把第一个字母用分组包含起来，\n我自己实现是这样子的，使用了非贪婪模式([a-z]).*?\\1，\n存在一个问题，会将 google 中，goog 匹配到，是因为没有限制单词的边界，可在结尾处使用 \\b 进行限制。\n最终结果：([a-z]).*？\\1\\b，\n前瞻和后顾 Lookahead \u0026amp; Lookbehind 前瞻是匹配到某些字符前面的内容，后顾就是匹配到某些字符后面的内容。\n前瞻和后顾是一种特殊的匹配方式，按照是否匹配还可以分为 正向前瞻、负向前瞻、正向后顾 和 负向后顾。\n简单说，就是匹配到某些字符前面或者后面的内容，但不包括这些字符本身\npositive lookahead. Matches a group after the main expression without including it in the result。正向前瞻，匹配主表达式后的组，但不将其包含在结果中 Negative lookahead. Specifies a group that can not match after the main expression(if it matches, the result is discarded). 负向前瞻，指定主表达式后不能匹配的组(如果匹配，则丢弃结果) Positive lookbehind. Matches a group before the main expression without including it in the result. 正向后顾，匹配主表达式之前的组，但不将其包含在结果中。 Negative lookbehind. Specifies a group that can not match before the main expression(if it matches, the result is discarded). 负向后顾，指定一个不能在主表达式之前匹配的组(如果匹配，则丢弃结果) 例子1：匹配数字前方的$，如下，要匹配第一个和第四个 $\n$100 $dasdf $f2fda $2dfas\n对应正则表达式：\\$(?=\\d+)，？= 代表正向前瞻，只有数字前方的 $ 被匹配到了，这就是正向前瞻\n如果将 ？= 替换为 ？！，代表 负向前瞻，就是 ？= 的取反，也就是 当后面内部不是数字的时候，匹配前方的 $，对应正则表达式 \\$(?!\\d+)，对应第二个和第三个。\n还是上面的例子，如果想匹配到以 $ 开头的数字，需要给前面的 $ 加上一个分组，括号里面再加上一个 ?\u0026lt;=，这个符号代表正向后顾，(?\u0026lt;=\\$)\\d+ 可以匹配到 100 和 2，\n将 = 替换为 ！，表示负向后顾\n其他 版本\n正则表达式的不同版本\nPOSIX 基本 - Baisc Regular Expression（BRE） POSIX 扩展 - Extended Regular Expression (ERE) Perl 兼容正则表达式（PCRE） 其他版本（Python、Java 等） 不同版本之间，可能会有一些不同的特性和差异\n比如，前瞻和后顾，在 js 中，直到 SE2018 之后采开始支持\nLinux 中，grep、sed 和 awk 等工具，都是基于 POSIX 标准的 BRE 或者 ERE，对于一些现代的正则表达式中的特性也是不支持的。\n如果 正则表达式没有匹配到想要的结果，可能是版本不支持，这时候就需要查一下对应版本的文档，查看支持的特性和语法，再做相应调整。\n总结 字符匹配 位置匹配 量词 分组和引用 前瞻和后顾 Python 特性 分组命名\n这是我工作中用到的一个正则表达式：\n1 2 3 start_time_p_3 = re.compile( r\u0026#39;start_time\\s*:\\s*(?P\u0026lt;time\u0026gt;\\d+.*?\\d+.*?\\d+\\s*\\d+.*?\\d+.*?\\d+).*status\\s*=\\s*(?P\u0026lt;status\u0026gt;\\d+)\u0026#39; ) 在Python的re模块中，确实可以通过(?P\u0026lt;name\u0026gt;...)这样的语法来为正则表达式中的分组命名。这种方式相比于传统的数字索引方式（如group(1)）更加直观和方便，特别是当你的正则表达式中有多个分组，并且这些分组并不是按照顺序使用的时候。\n当你使用这个编译后的正则表达式对象去搜索或匹配文本时，可以通过分组的名字来提取信息，例如：\n1 2 3 4 pythonmatch = start_time_p_3.search(some_text) if match: print(match.group(\u0026#39;time\u0026#39;)) # 输出匹配到的时间部分 print(match.group(\u0026#39;status\u0026#39;)) # 输出匹配到的状态部分 这种方式使得提取特定部分的信息变得更加容易管理，尤其是在处理复杂的字符串解析任务时。\n正则表达式命名分组确实是Python re 模块的一个特性。这种语法 (?P\u0026lt;name\u0026gt;...) 是Python特有的，并不是所有正则表达式引擎都支持这种语法。以下\nPython 中的命名分组 在Python中，re 模块支持命名分组，这使得提取信息更加直观和方便。具体来说：\n(?P\u0026lt;name\u0026gt;...) 用于定义一个名为 name 的分组。 可以通过 match.group('name') 来访问命名分组的内容。 在其他环境中，如JavaScript、Java、.NET 或者一些在线正则表达式测试工具，通常不支持这种命名分组的语法。它们通常使用不同的方法来实现类似的功能。\ngroup方法返回一个或者多个匹配的子组。如果只有一个参数，结果就是一个字符串，如果有多个参数，结果就是一个元组（每个参数对应一个项），如果没有参数，整个匹配都被返回。 如果一个参数值为 0，即是group(0)，相应的返回值就是整个匹配字符串；如果它是一个范围 [1..99]，结果就是相应的括号组字符串。如果一个组号是负数，或者大于样式中定义的组数，一个 IndexError 索引错误就 raise。如果一个组包含在样式的一部分，并被匹配多次，就返回最后一个匹配。 ————————————————\n版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 原文链接：https://blog.csdn.net/a66666_/article/details/103412774\nJavaScript 在JavaScript中，可以使用命名捕获组，但是语法略有不同：\n1 2 3 4 5 6 javascriptconst regex = /start_time\\s*:\\s*(?\u0026lt;time\u0026gt;\\d+.*?\\d+.*?\\d+\\s*\\d+.*?\\d+.*?\\d+).*status\\s*=\\s*(?\u0026lt;status\u0026gt;\\d+)/; const match = regex.exec(someText); if (match) { console.log(match.groups.time); // 输出匹配到的时间部分 console.log(match.groups.status); // 输出匹配到的状态部分 } VSCode 在 vscode 中，可以用 正则模式，快速在每一行的开头或结尾 替换数据。开启正则模式。输入 ^ 或 $ ，\n正则表达式\nre模块 re模块中，常用 re.match、re.serach、re.findall\nlinux 和 mac系统中，可以通过 grep 和 sed 等命令使用正则表达式进行文本处理\n视频中的正则表达式在线工具网站：https://regexr.com\n左边是导航栏，可以切换设置或者查看帮助文档\npython 的 re模块\ngroup group方法返回一个或者多个匹配的子组。如果只有一个参数，结果就是一个字符串，如果有多个参数，结果就是一个元组（每个参数对应一个项），如果没有参数，整个匹配都被返回。 如果一个参数值为 0，即是group(0)，相应的返回值就是整个匹配字符串；如果它是一个范围 [1..99]，结果就是相应的括号组字符串。如果一个组号是负数，或者大于样式中定义的组数，一个 IndexError 索引错误就 raise。如果一个组包含在样式的一部分，并被匹配多次，就返回最后一个匹配。\n使用了 (?P\u0026lt;name\u0026gt;…) 语法， group(n)中，参数n就也可能是命名组合的名字。如果一个字符串参数在样式中未定义为组合名，一个 IndexError 就 raise。\n1 2 3 4 5 6 7 a = r\u0026#39;start_time\\s*:\\s*(?P\u0026lt;time\u0026gt;\\d+.*?\\d+.*?\\d+\\s*\\d+.*?\\d+.*?\\d+).*status\\s*=\\s*(?P\u0026lt;status\u0026gt;\\d+)\u0026#39; y = re.search(a,\u0026#34;IMU:start_time:2023-07-19 15:47:28 status=1\u0026#34;) print(y.group(\u0026#39;time\u0026#39;)) print(y.group(\u0026#39;status\u0026#39;)) 2023-07-19 15:47:28 1 字符串：IMU:start_time:2023-07-19 15:47:28 status=1\n参考教材：\n30分钟正则表达式教程_哔哩哔哩_bilibili 正则表达式不要背正则表达式一直是困扰很多程序员的一门技术，当然也包括曾经的我。大多数时候我们在开发过程中要用到某些正则表 - 掘金 (juejin.cn) 贪婪匹配：https://blog.csdn.net/lekusun9671/article/details/105066676\n文档：https://docs.python.org/zh-cn/3/howto/regex.html\nre.group：https://blog.csdn.net/a66666_/article/details/103412774\n正则表达式不要背：https://juejin.cn/post/6844903845227659271\n","permalink":"https://wangkai26.github.io/posts/tech/regex/principles/","summary":"正则表达式(Regular Expression)是一种文本模式，包括普通字符（例如，a 到 z 之间的字母）和特殊字符（称为\u0026quot;元字符\u0026q","title":"Principles"},{"content":"科幻小说《球状闪电》, i like it 触发构建\n","permalink":"https://wangkai26.github.io/posts/read/read_demo/","summary":"科幻小说《球状闪电》, i like it 触发构建","title":"Read_demo"},{"content":"gg 哈哈哈\n","permalink":"https://wangkai26.github.io/posts/life/life_second/gg/","summary":"gg 哈哈哈","title":"Gg"},{"content":"hello life module\n","permalink":"https://wangkai26.github.io/posts/life/life_demo2/","summary":"hello life module","title":"Life_demo2"},{"content":"demo2\n","permalink":"https://wangkai26.github.io/posts/tech/demo2/","summary":"demo2","title":"Demo2"},{"content":"demo1\n试一下 abc 的啊发 edf\none two three fasf\none two three ","permalink":"https://wangkai26.github.io/posts/tech/demo1/","summary":"demo1 试一下 abc 的啊发 edf one two three fasf one two three","title":"Demo1"},{"content":"start\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 import math import numpy as np def get_tile_number(latitude, longitude, zoom_level): num_tiles = 2 ** zoom_level # 计算每个瓦片的经度和纬度范围 tile_longitude_range = 360.0 / num_tiles tile_latitude_range = 170.1022 / num_tiles # 计算给定经纬度点所属的瓦片行列号 tile_column = int((longitude + 180) / tile_longitude_range) tile_row = int((90 - latitude) / tile_latitude_range) # tileX = (longitude + 180) / 360 * (2 ** zoom_level) # tileY = 1/2 - (np.log()) math.sec # (180 - Math.log(Math.tan(Math.PI / 4 + lat * Math.PI / 360)) * 180 / Math.PI) / 360 # return tile_column, tile_row # 示例经纬度点 latitude = 22.962191 longitude = 113.888899 zoom_level = 12 # tile_column, tile_row = get_tile_number(latitude, longitude, zoom_level) # print(\u0026#34;瓦片行列号：\u0026#34;, tile_column, tile_row) import math def deg2num(lat_deg, lon_deg, zoom): lat_rad = math.radians(lat_deg) n = 1 \u0026lt;\u0026lt; zoom xtile = int((lon_deg + 180.0) / 360.0 * n) ytile = int((1.0 - math.asinh(math.tan(lat_rad)) / math.pi) / 2.0 * n) return xtile, ytile print(\u0026#34;公司:\u0026#34;,deg2num(22.962191,113.888899,zoom_level)) print(\u0026#34;刘臻:\u0026#34;,deg2num(34.0240280,-118.5022140,zoom_level)) print(deg2num(22.959263,113.893807,zoom_level)) print(deg2num(22.962191,113.888902,zoom_level)) # lat\u0026#39;:340240280,\u0026#39;long\u0026#39;:-1185022140 end\n","permalink":"https://wangkai26.github.io/about/","summary":"start 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 import math import numpy as np def get_tile_number(latitude, longitude, zoom_level): num_tiles = 2 ** zoom_level # 计算每个瓦片的经度和","title":"About"},{"content":"asdf\n","permalink":"https://wangkai26.github.io/posts/life/life_demo1/","summary":"asdf","title":""},{"content":"","permalink":"https://wangkai26.github.io/posts/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%83%A8%E7%BD%B2%E4%B8%8E%E9%85%8D%E7%BD%AE/","summary":"","title":"服务端部署与配置"}]